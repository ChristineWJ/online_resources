<!DOCTYPE html><html><head><meta charset="utf-8"><title>Untitled Document.md</title><script type="text/javascript">
//<![CDATA[
window.__cfRocketOptions = {byc:0,p:0,petok:"c90eecbbcee051a35e64be39ef656d69c6ce26e8-1510118288-1800"};
//]]>
</script>
<script type="text/javascript" src="https://ajax.cloudflare.com/cdn-cgi/scripts/78d64697/cloudflare-static/rocket.min.js"></script>
<style></style></head><body id="preview">
<h1><a id="C_0"></a>C语言数据结构（浙大）</h1>
<h1><a id="13_2"></a><strong>1.3最大子列和问题</strong></h1>
<pre><code class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max3</span><span class="hljs-params">( <span class="hljs-keyword">int</span> A, <span class="hljs-keyword">int</span> B, <span class="hljs-keyword">int</span> C )</span>
</span>{ <span class="hljs-comment">/* 返回3个整数中的最大值 */</span>
    <span class="hljs-keyword">return</span> A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;
}
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DivideAndConquer</span><span class="hljs-params">( <span class="hljs-keyword">int</span> List[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right )</span>
</span>{ <span class="hljs-comment">/* 分治法求List[left]到List[right]的最大子列和 */</span>
    <span class="hljs-keyword">int</span> MaxLeftSum, MaxRightSum; <span class="hljs-comment">/* 存放左右子问题的解 */</span>
    <span class="hljs-keyword">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="hljs-comment">/*存放跨分界线的结果*/</span>
 
    <span class="hljs-keyword">int</span> LeftBorderSum, RightBorderSum;
    <span class="hljs-keyword">int</span> center, i;
 
    <span class="hljs-keyword">if</span>( left == right )  { <span class="hljs-comment">/* 递归的终止条件，子列只有1个数字 */</span>
        <span class="hljs-keyword">if</span>( List[left] &gt; <span class="hljs-number">0</span> )  <span class="hljs-keyword">return</span> List[left];
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
 
    <span class="hljs-comment">/* 下面是"分"的过程 */</span>
    center = ( left + right ) / <span class="hljs-number">2</span>; <span class="hljs-comment">/* 找到中分点 */</span>
    <span class="hljs-comment">/* 递归求得两边子列的最大和 */</span>
    MaxLeftSum = DivideAndConquer( List, left, center );
    MaxRightSum = DivideAndConquer( List, center+<span class="hljs-number">1</span>, right );
 
    <span class="hljs-comment">/* 下面求跨分界线的最大子列和 */</span>
    MaxLeftBorderSum = <span class="hljs-number">0</span>; LeftBorderSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>( i=center; i&gt;=left; i-- ) { <span class="hljs-comment">/* 从中线向左扫描 */</span>
        LeftBorderSum += List[i];
        <span class="hljs-keyword">if</span>( LeftBorderSum &gt; MaxLeftBorderSum )
            MaxLeftBorderSum = LeftBorderSum;
    } <span class="hljs-comment">/* 左边扫描结束 */</span>
 
    MaxRightBorderSum = <span class="hljs-number">0</span>; RightBorderSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>( i=center+<span class="hljs-number">1</span>; i&lt;=right; i++ ) { <span class="hljs-comment">/* 从中线向右扫描 */</span>
        RightBorderSum += List[i];
        <span class="hljs-keyword">if</span>( RightBorderSum &gt; MaxRightBorderSum )
            MaxRightBorderSum = RightBorderSum;
    } <span class="hljs-comment">/* 右边扫描结束 */</span>
 
    <span class="hljs-comment">/* 下面返回"治"的结果 */</span>
    <span class="hljs-keyword">return</span> Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubseqSum3</span><span class="hljs-params">( <span class="hljs-keyword">int</span> List[], <span class="hljs-keyword">int</span> N )</span>
</span>{ <span class="hljs-comment">/* 保持与前2种算法相同的函数接口 */</span>
    <span class="hljs-keyword">return</span> DivideAndConquer( List, <span class="hljs-number">0</span>, N-<span class="hljs-number">1</span> );
}
</code></pre>
<hr>
<p><strong>2.1线性表</strong></p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Position;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> LNode *List;
<span class="hljs-keyword">struct</span> LNode {
    ElementType Data[MAXSIZE];
    Position Last;
};
 
<span class="hljs-comment">/* 初始化 */</span>
<span class="hljs-function">List <span class="hljs-title">MakeEmpty</span><span class="hljs-params">()</span>
</span>{
    List L;
 
    L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));
    L-&gt;Last = -<span class="hljs-number">1</span>;
 
    <span class="hljs-keyword">return</span> L;
}
 
<span class="hljs-comment">/* 查找 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ERROR -<span class="hljs-number">1</span></span>
 
<span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( List L, ElementType X )</span>
</span>{
    Position i = <span class="hljs-number">0</span>;
 
    <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )
        i++;
    <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span>
    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span>
}
 
<span class="hljs-comment">/* 插入 */</span>
<span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> 
</span>{ <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span>
    Position i;
 
    <span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE-<span class="hljs-number">1</span>) {
        <span class="hljs-comment">/* 表空间已满，不能插入 */</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"表满"</span>); 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; 
    }  
    <span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> ) { <span class="hljs-comment">/* 检查插入位置的合法性 */</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置不合法"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; 
    } 
    <span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )
        L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span>
    L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span>
    L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; 
} 
 
<span class="hljs-comment">/* 删除 */</span>
<span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Delete</span><span class="hljs-params">( List L, Position P )</span>
</span>{ <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span>
    Position i;
 
    <span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) { <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置%d不存在元素"</span>, P ); 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; 
    }
    <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ )
        L-&gt;Data[i-<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span>
    L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   
}
</code></pre>
<hr>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> LNode *PtrToLNode;
<span class="hljs-keyword">struct</span> LNode {
    ElementType Data;
    PtrToLNode Next;
};
<span class="hljs-keyword">typedef</span> PtrToLNode Position;
<span class="hljs-keyword">typedef</span> PtrToLNode List;
 
<span class="hljs-comment">/* 查找 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ERROR NULL</span>
 
<span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( List L, ElementType X )</span>
</span>{
    Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span>
 
    <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )
        p = p-&gt;Next;
 
    <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span>
    <span class="hljs-keyword">if</span> ( p )
        <span class="hljs-keyword">return</span> p;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> ERROR;
}
 
<span class="hljs-comment">/* 带头结点的插入 */</span>
<span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span>
</span>{ <span class="hljs-comment">/* 这里默认L有头结点 */</span>
    Position tmp, pre;
 
    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        
    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            
    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) { <span class="hljs-comment">/* P所指的结点不在L中 */</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置参数错误\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>
        <span class="hljs-comment">/* 在P前插入新结点 */</span>
        tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode)); <span class="hljs-comment">/* 申请、填装结点 */</span>
        tmp-&gt;Data = X; 
        tmp-&gt;Next = P;
        pre-&gt;Next = tmp;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
 
<span class="hljs-comment">/* 带头结点的删除 */</span>
<span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Delete</span><span class="hljs-params">( List L, Position P )</span>
</span>{ <span class="hljs-comment">/* 这里默认L有头结点 */</span>
    Position tmp, pre;
 
    <span class="hljs-comment">/* 查找P的前一个结点 */</span>        
    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            
    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>) { <span class="hljs-comment">/* P所指的结点不在L中 */</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置参数错误\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>
        <span class="hljs-comment">/* 将P位置的结点删除 */</span>
        pre-&gt;Next = P-&gt;Next;
        <span class="hljs-built_in">free</span>(P);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p><strong>堆栈</strong>*</p>
<pre><code class="language-c">typedef int Position;
struct SNode {
    ElementType *Data; /* 存储元素的数组 */
    Position Top;      /* 栈顶指针 */
    int MaxSize;       /* 堆栈最大容量 */
};
typedef struct SNode *Stack;
 
Stack CreateStack( int MaxSize )
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top = -1;
    S-&gt;MaxSize = MaxSize;
    return S;
}
 
bool IsFull( Stack S )
{
    return (S-&gt;Top == S-&gt;MaxSize-1);
}
 
bool Push( Stack S, ElementType X )
{
    if ( IsFull(S) ) {
        printf("堆栈满");
        return false;
    }
    else {
        S-&gt;Data[++(S-&gt;Top)] = X;
        return true;
    }
}
 
bool IsEmpty( Stack S )
{
    return (S-&gt;Top == -1);
}
 
ElementType Pop( Stack S )
{
    if ( IsEmpty(S) ) {
        printf("堆栈空");
        return ERROR; /* ERROR是ElementType的特殊值，标志错误 */
    }
    else 
        return ( S-&gt;Data[(S-&gt;Top)--] );
}
</code></pre>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> SNode *PtrToSNode;
<span class="hljs-keyword">struct</span> SNode {
    ElementType Data;
    PtrToSNode Next;
};
<span class="hljs-keyword">typedef</span> PtrToSNode Stack;
 
<span class="hljs-function">Stack <span class="hljs-title">CreateStack</span><span class="hljs-params">( )</span> 
</span>{ <span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span>
    Stack S;
 
    S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));
    S-&gt;Next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> S;
}
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span> <span class="hljs-params">( Stack S )</span>
</span>{ <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span>
    <span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> );
}
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">( Stack S, ElementType X )</span>
</span>{ <span class="hljs-comment">/* 将元素X压入堆栈S */</span>
    PtrToSNode TmpCell;
 
    TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));
    TmpCell-&gt;Data = X;
    TmpCell-&gt;Next = S-&gt;Next;
    S-&gt;Next = TmpCell;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
 
<span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">( Stack S )</span>  
</span>{ <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span>
    PtrToSNode FirstCell;
    ElementType TopElem;
 
    <span class="hljs-keyword">if</span>( IsEmpty(S) ) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"堆栈空"</span>); 
        <span class="hljs-keyword">return</span> ERROR;
    }
    <span class="hljs-keyword">else</span> {
        FirstCell = S-&gt;Next; 
        TopElem = FirstCell-&gt;Data;
        S-&gt;Next = FirstCell-&gt;Next;
        <span class="hljs-built_in">free</span>(FirstCell);
        <span class="hljs-keyword">return</span> TopElem;
    }
}
</code></pre>
<p><strong>队列</strong></p>
<pre><code class="language-c">typedef int Position;
struct QNode {
    ElementType *Data;     /* 存储元素的数组 */
    Position Front, Rear;  /* 队列的头、尾指针 */
    int MaxSize;           /* 队列最大容量 */
};
typedef struct QNode *Queue;
 
Queue CreateQueue( int MaxSize )
{
    Queue Q = (Queue)malloc(sizeof(struct QNode));
    Q-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    Q-&gt;Front = Q-&gt;Rear = 0;
    Q-&gt;MaxSize = MaxSize;
    return Q;
}
 
bool IsFull( Queue Q )
{
    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);
}
 
bool AddQ( Queue Q, ElementType X )
{
    if ( IsFull(Q) ) {
        printf("队列满");
        return false;
    }
    else {
        Q-&gt;Rear = (Q-&gt;Rear+1)%Q-&gt;MaxSize;
        Q-&gt;Data[Q-&gt;Rear] = X;
        return true;
    }
}
 
bool IsEmpty( Queue Q )
{
    return (Q-&gt;Front == Q-&gt;Rear);
}
 
ElementType DeleteQ( Queue Q )
{
    if ( IsEmpty(Q) ) { 
        printf("队列空");
        return ERROR;
    }
    else  {
        Q-&gt;Front =(Q-&gt;Front+1)%Q-&gt;MaxSize;
        return  Q-&gt;Data[Q-&gt;Front];
    }
}
</code></pre>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Node *PtrToNode;
<span class="hljs-keyword">struct</span> Node { <span class="hljs-comment">/* 队列中的结点 */</span>
    ElementType Data;
    PtrToNode Next;
};
<span class="hljs-keyword">typedef</span> PtrToNode Position;
 
<span class="hljs-keyword">struct</span> QNode {
    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>
    <span class="hljs-keyword">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span>
};
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> QNode *Queue;
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">( Queue Q )</span>
</span>{
    <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>);
}
 
<span class="hljs-function">ElementType <span class="hljs-title">DeleteQ</span><span class="hljs-params">( Queue Q )</span>
</span>{
    Position FrontCell; 
    ElementType FrontElem;
     
    <span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"队列空"</span>);
        <span class="hljs-keyword">return</span> ERROR;
    }
    <span class="hljs-keyword">else</span> {
        FrontCell = Q-&gt;Front;
        <span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>
            Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span>
        <span class="hljs-keyword">else</span>                     
            Q-&gt;Front = Q-&gt;Front-&gt;Next;
        FrontElem = FrontCell-&gt;Data;
 
        <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>
        <span class="hljs-keyword">return</span>  FrontElem;
    }
}
</code></pre>
<p><strong>二叉树</strong></p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> TNode *Position;
<span class="hljs-keyword">typedef</span> Position BinTree; <span class="hljs-comment">/* 二叉树类型 */</span>
<span class="hljs-keyword">struct</span> TNode{ <span class="hljs-comment">/* 树结点定义 */</span>
    ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>
    BinTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>
    BinTree Right;    <span class="hljs-comment">/* 指向右子树 */</span>
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span>
</span>{
    <span class="hljs-keyword">if</span>( BT ) {
        InorderTraversal( BT-&gt;Left );
        <span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span>
        InorderTraversal( BT-&gt;Right );
    }
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span>
</span>{
    <span class="hljs-keyword">if</span>( BT ) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, BT-&gt;Data );
        PreorderTraversal( BT-&gt;Left );
        PreorderTraversal( BT-&gt;Right );
    }
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span>
</span>{
    <span class="hljs-keyword">if</span>( BT ) {
        PostorderTraversal( BT-&gt;Left );
        PostorderTraversal( BT-&gt;Right );
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, BT-&gt;Data);
    }
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span>
</span>{ 
    Queue Q; 
    BinTree T;
 
    <span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span>
     
    Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span>
    AddQ( Q, BT );
    <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) {
        T = DeleteQ( Q );
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span>
        <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );
        <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );
    }
}
</code></pre>
<p><strong>二叉搜索树</strong></p>
<pre><code class="language-c"><span class="hljs-function">BinTree <span class="hljs-title">Insert</span><span class="hljs-params">( BinTree BST, ElementType X )</span>
</span>{
    <span class="hljs-keyword">if</span>( !BST ){ <span class="hljs-comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span>
        BST = (BinTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TNode));
        BST-&gt;Data = X;
        BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 开始找要插入元素的位置 */</span>
        <span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )
            BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class="hljs-comment">/*递归插入左子树*/</span>
        <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )
            BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class="hljs-comment">/*递归插入右子树*/</span>
        <span class="hljs-comment">/* else X已经存在，什么都不做 */</span>
    }
    <span class="hljs-keyword">return</span> BST;
}
 
<span class="hljs-function">BinTree <span class="hljs-title">Delete</span><span class="hljs-params">( BinTree BST, ElementType X )</span> 
</span>{ 
    Position Tmp; 
 
    <span class="hljs-keyword">if</span>( !BST ) 
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"要删除的元素未找到"</span>); 
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data ) 
            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="hljs-comment">/* 从左子树递归删除 */</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data ) 
            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="hljs-comment">/* 从右子树递归删除 */</span>
        <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* BST就是要删除的结点 */</span>
            <span class="hljs-comment">/* 如果被删除结点有左右两个子结点 */</span> 
            <span class="hljs-keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) {
                <span class="hljs-comment">/* 从右子树中找最小的元素填充删除结点 */</span>
                Tmp = FindMin( BST-&gt;Right );
                BST-&gt;Data = Tmp-&gt;Data;
                <span class="hljs-comment">/* 从右子树中删除最小元素 */</span>
                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );
            }
            <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 被删除结点有一个或无子结点 */</span>
                Tmp = BST; 
                <span class="hljs-keyword">if</span>( !BST-&gt;Left )       <span class="hljs-comment">/* 只有右孩子或无子结点 */</span>
                    BST = BST-&gt;Right; 
                <span class="hljs-keyword">else</span>                   <span class="hljs-comment">/* 只有左孩子 */</span>
                    BST = BST-&gt;Left;
                <span class="hljs-built_in">free</span>( Tmp );
            }
        }
    }
    <span class="hljs-keyword">return</span> BST;
}
</code></pre>
<p><strong>儿茶平衡树</strong></p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> AVLNode *Position;
<span class="hljs-keyword">typedef</span> Position AVLTree; <span class="hljs-comment">/* AVL树类型 */</span>
<span class="hljs-keyword">struct</span> AVLNode{
    ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>
    AVLTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>
    AVLTree Right;    <span class="hljs-comment">/* 指向右子树 */</span>
    <span class="hljs-keyword">int</span> Height;       <span class="hljs-comment">/* 树高 */</span>
};
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b )</span>
</span>{
    <span class="hljs-keyword">return</span> a &gt; b ? a : b;
}
 
<span class="hljs-function">AVLTree <span class="hljs-title">SingleLeftRotation</span> <span class="hljs-params">( AVLTree A )</span>
</span>{ <span class="hljs-comment">/* 注意：A必须有一个左子结点B */</span>
  <span class="hljs-comment">/* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */</span>     
 
    AVLTree B = A-&gt;Left;
    A-&gt;Left = B-&gt;Right;
    B-&gt;Right = A;
    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + <span class="hljs-number">1</span>;
    B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + <span class="hljs-number">1</span>;
  
    <span class="hljs-keyword">return</span> B;
}
 
<span class="hljs-function">AVLTree <span class="hljs-title">DoubleLeftRightRotation</span> <span class="hljs-params">( AVLTree A )</span>
</span>{ <span class="hljs-comment">/* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */</span>
  <span class="hljs-comment">/* 将A、B与C做两次单旋，返回新的根结点C */</span>
     
    <span class="hljs-comment">/* 将B与C做右单旋，C被返回 */</span>
    A-&gt;Left = SingleRightRotation(A-&gt;Left);
    <span class="hljs-comment">/* 将A与C做左单旋，C被返回 */</span>
    <span class="hljs-keyword">return</span> SingleLeftRotation(A);
}
 
<span class="hljs-comment">/*************************************/</span>
<span class="hljs-comment">/* 对称的右单旋与右-左双旋请自己实现 */</span>
<span class="hljs-comment">/*************************************/</span>
 
<span class="hljs-function">AVLTree <span class="hljs-title">Insert</span><span class="hljs-params">( AVLTree T, ElementType X )</span>
</span>{ <span class="hljs-comment">/* 将X插入AVL树T中，并且返回调整后的AVL树 */</span>
    <span class="hljs-keyword">if</span> ( !T ) { <span class="hljs-comment">/* 若插入空树，则新建包含一个结点的树 */</span>
        T = (AVLTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AVLNode));
        T-&gt;Data = X;
        T-&gt;Height = <span class="hljs-number">0</span>;
        T-&gt;Left = T-&gt;Right = <span class="hljs-literal">NULL</span>;
    } <span class="hljs-comment">/* if (插入空树) 结束 */</span>
 
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Data ) {
        <span class="hljs-comment">/* 插入T的左子树 */</span>
        T-&gt;Left = Insert( T-&gt;Left, X);
        <span class="hljs-comment">/* 如果需要左旋 */</span>
        <span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">2</span> )
            <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Left-&gt;Data ) 
               T = SingleLeftRotation(T);      <span class="hljs-comment">/* 左单旋 */</span>
            <span class="hljs-keyword">else</span> 
               T = DoubleLeftRightRotation(T); <span class="hljs-comment">/* 左-右双旋 */</span>
    } <span class="hljs-comment">/* else if (插入左子树) 结束 */</span>
     
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Data ) {
        <span class="hljs-comment">/* 插入T的右子树 */</span>
        T-&gt;Right = Insert( T-&gt;Right, X );
        <span class="hljs-comment">/* 如果需要右旋 */</span>
        <span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == -<span class="hljs-number">2</span> )
            <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Right-&gt;Data ) 
               T = SingleRightRotation(T);     <span class="hljs-comment">/* 右单旋 */</span>
            <span class="hljs-keyword">else</span> 
               T = DoubleRightLeftRotation(T); <span class="hljs-comment">/* 右-左双旋 */</span>
    } <span class="hljs-comment">/* else if (插入右子树) 结束 */</span>
 
    <span class="hljs-comment">/* else X == T-&gt;Data，无须插入 */</span>
 
    <span class="hljs-comment">/* 别忘了更新树高 */</span>
    T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + <span class="hljs-number">1</span>;
     
    <span class="hljs-keyword">return</span> T;
}
</code></pre>
<p><strong>堆</strong></p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> HNode *Heap; <span class="hljs-comment">/* 堆的类型定义 */</span>
<span class="hljs-keyword">struct</span> HNode {
    ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span>
    <span class="hljs-keyword">int</span> Size;          <span class="hljs-comment">/* 堆中当前元素个数 */</span>
    <span class="hljs-keyword">int</span> Capacity;      <span class="hljs-comment">/* 堆的最大容量 */</span>
};
<span class="hljs-keyword">typedef</span> Heap MaxHeap; <span class="hljs-comment">/* 最大堆 */</span>
<span class="hljs-keyword">typedef</span> Heap MinHeap; <span class="hljs-comment">/* 最小堆 */</span>
 
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXDATA <span class="hljs-number">1000</span>  <span class="hljs-comment">/* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span></span>
 
<span class="hljs-function">MaxHeap <span class="hljs-title">CreateHeap</span><span class="hljs-params">( <span class="hljs-keyword">int</span> MaxSize )</span>
</span>{ <span class="hljs-comment">/* 创建容量为MaxSize的空的最大堆 */</span>
 
    MaxHeap H = (MaxHeap)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> HNode));
    H-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>((MaxSize+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(ElementType));
    H-&gt;Size = <span class="hljs-number">0</span>;
    H-&gt;Capacity = MaxSize;
    H-&gt;Data[<span class="hljs-number">0</span>] = MAXDATA; <span class="hljs-comment">/* 定义"哨兵"为大于堆中所有可能元素的值*/</span>
 
    <span class="hljs-keyword">return</span> H;
}
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">( MaxHeap H )</span>
</span>{
    <span class="hljs-keyword">return</span> (H-&gt;Size == H-&gt;Capacity);
}
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">( MaxHeap H, ElementType X )</span>
</span>{ <span class="hljs-comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span>
    <span class="hljs-keyword">int</span> i;
  
    <span class="hljs-keyword">if</span> ( IsFull(H) ) { 
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大堆已满"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    i = ++H-&gt;Size; <span class="hljs-comment">/* i指向插入后堆中的最后一个元素的位置 */</span>
    <span class="hljs-keyword">for</span> ( ; H-&gt;Data[i/<span class="hljs-number">2</span>] &lt; X; i/=<span class="hljs-number">2</span> )
        H-&gt;Data[i] = H-&gt;Data[i/<span class="hljs-number">2</span>]; <span class="hljs-comment">/* 上滤X */</span>
    H-&gt;Data[i] = X; <span class="hljs-comment">/* 将X插入 */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
 
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ERROR -<span class="hljs-number">1</span> <span class="hljs-comment">/* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">( MaxHeap H )</span>
</span>{
    <span class="hljs-keyword">return</span> (H-&gt;Size == <span class="hljs-number">0</span>);
}
 
<span class="hljs-function">ElementType <span class="hljs-title">DeleteMax</span><span class="hljs-params">( MaxHeap H )</span>
</span>{ <span class="hljs-comment">/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span>
    <span class="hljs-keyword">int</span> Parent, Child;
    ElementType MaxItem, X;
 
    <span class="hljs-keyword">if</span> ( IsEmpty(H) ) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大堆已为空"</span>);
        <span class="hljs-keyword">return</span> ERROR;
    }
 
    MaxItem = H-&gt;Data[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* 取出根结点存放的最大值 */</span>
    <span class="hljs-comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span>
    X = H-&gt;Data[H-&gt;Size--]; <span class="hljs-comment">/* 注意当前堆的规模要减小 */</span>
    <span class="hljs-keyword">for</span>( Parent=<span class="hljs-number">1</span>; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) {
        Child = Parent * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )
            Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>
        <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>
        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
 
    <span class="hljs-keyword">return</span> MaxItem;
} 
 
<span class="hljs-comment">/*----------- 建造最大堆 -----------*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PercDown</span><span class="hljs-params">( MaxHeap H, <span class="hljs-keyword">int</span> p )</span>
</span>{ <span class="hljs-comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span>
    <span class="hljs-keyword">int</span> Parent, Child;
    ElementType X;
 
    X = H-&gt;Data[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span>
    <span class="hljs-keyword">for</span>( Parent=p; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) {
        Child = Parent * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )
            Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>
        <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>
        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildHeap</span><span class="hljs-params">( MaxHeap H )</span>
</span>{ <span class="hljs-comment">/* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span>
  <span class="hljs-comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span>
 
    <span class="hljs-keyword">int</span> i;
 
    <span class="hljs-comment">/* 从最后一个结点的父节点开始，到根结点1 */</span>
    <span class="hljs-keyword">for</span>( i = H-&gt;Size/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i-- )
        PercDown( H, i );
}
</code></pre>
<p><strong>集合及运算</strong></p>
<pre><code class="language-c"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXN <span class="hljs-number">1000</span>                  <span class="hljs-comment">/* 集合最大元素个数 */</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElementType;           <span class="hljs-comment">/* 默认元素可以用非负整数表示 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> SetName;               <span class="hljs-comment">/* 默认用根结点的下标作为集合名称 */</span>
<span class="hljs-keyword">typedef</span> ElementType SetType[MAXN]; <span class="hljs-comment">/* 假设集合元素下标从0开始 */</span>
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2 )</span>
</span>{ <span class="hljs-comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span>
    <span class="hljs-comment">/* 保证小集合并入大集合 */</span>
    <span class="hljs-keyword">if</span> ( S[Root2] &lt; S[Root1] ) { <span class="hljs-comment">/* 如果集合2比较大 */</span>
        S[Root2] += S[Root1];     <span class="hljs-comment">/* 集合1并入集合2  */</span>
        S[Root1] = Root2;
    }
    <span class="hljs-keyword">else</span> {                         <span class="hljs-comment">/* 如果集合1比较大 */</span>
        S[Root1] += S[Root2];     <span class="hljs-comment">/* 集合2并入集合1  */</span>
        S[Root2] = Root1;
    }
}
 
<span class="hljs-function">SetName <span class="hljs-title">Find</span><span class="hljs-params">( SetType S, ElementType X )</span>
</span>{ <span class="hljs-comment">/* 默认集合元素全部初始化为-1 */</span>
    <span class="hljs-keyword">if</span> ( S[X] &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">/* 找到集合的根 */</span>
        <span class="hljs-keyword">return</span> X;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> S[X] = Find( S, S[X] ); <span class="hljs-comment">/* 路径压缩 */</span>
}
</code></pre>
<p><strong>图</strong></p>
<pre><code class="language-c"><span class="hljs-comment">/* 图的邻接矩阵表示法 */</span>
 
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MaxVertexNum <span class="hljs-number">100</span>    <span class="hljs-comment">/* 最大顶点数设为100 */</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> INFINITY <span class="hljs-number">65535</span>        <span class="hljs-comment">/* ∞设为双字节无符号整数的最大值65535*/</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span>
 
<span class="hljs-comment">/* 边的定义 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> ENode *PtrToENode;
<span class="hljs-keyword">struct</span> ENode{
    Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>
    WeightType Weight;  <span class="hljs-comment">/* 权重 */</span>
};
<span class="hljs-keyword">typedef</span> PtrToENode Edge;
        
<span class="hljs-comment">/* 图结点的定义 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> GNode *PtrToGNode;
<span class="hljs-keyword">struct</span> GNode{
    <span class="hljs-keyword">int</span> Nv;  <span class="hljs-comment">/* 顶点数 */</span>
    <span class="hljs-keyword">int</span> Ne;  <span class="hljs-comment">/* 边数   */</span>
    WeightType G[MaxVertexNum][MaxVertexNum]; <span class="hljs-comment">/* 邻接矩阵 */</span>
    DataType Data[MaxVertexNum];      <span class="hljs-comment">/* 存顶点的数据 */</span>
    <span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */</span>
};
<span class="hljs-keyword">typedef</span> PtrToGNode MGraph; <span class="hljs-comment">/* 以邻接矩阵存储的图类型 */</span>
 
 
 
<span class="hljs-function">MGraph <span class="hljs-title">CreateGraph</span><span class="hljs-params">( <span class="hljs-keyword">int</span> VertexNum )</span>
</span>{ <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>
    Vertex V, W;
    MGraph Graph;
     
    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode)); <span class="hljs-comment">/* 建立图 */</span>
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* 初始化邻接矩阵 */</span>
    <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)
        <span class="hljs-keyword">for</span> (W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++)  
            Graph-&gt;G[V][W] = INFINITY;
             
    <span class="hljs-keyword">return</span> Graph; 
}
        
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">( MGraph Graph, Edge E )</span>
</span>{
     <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>
     Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;    
     <span class="hljs-comment">/* 若是无向图，还要插入边&lt;V2, V1&gt; */</span>
     Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;
}
 
<span class="hljs-function">MGraph <span class="hljs-title">BuildGraph</span><span class="hljs-params">()</span>
</span>{
    MGraph Graph;
    Edge E;
    Vertex V;
    <span class="hljs-keyword">int</span> Nv, i;
     
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>
    Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span> 
     
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>
    <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) { <span class="hljs-comment">/* 如果有边 */</span> 
        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)); <span class="hljs-comment">/* 建立边结点 */</span> 
        <span class="hljs-comment">/* 读入边，格式为"起点 终点 权重"，插入邻接矩阵 */</span>
        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); 
            <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>
            InsertEdge( Graph, E );
        }
    } 
 
    <span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) 
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;(Graph-&gt;Data[V]));
 
    <span class="hljs-keyword">return</span> Graph;
}
</code></pre>
<pre><code class="language-c"><span class="hljs-comment">/* 图的邻接表表示法 */</span>
 
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MaxVertexNum <span class="hljs-number">100</span>    <span class="hljs-comment">/* 最大顶点数设为100 */</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span>
 
<span class="hljs-comment">/* 边的定义 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> ENode *PtrToENode;
<span class="hljs-keyword">struct</span> ENode{
    Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>
    WeightType Weight;  <span class="hljs-comment">/* 权重 */</span>
};
<span class="hljs-keyword">typedef</span> PtrToENode Edge;
 
<span class="hljs-comment">/* 邻接点的定义 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> AdjVNode *PtrToAdjVNode; 
<span class="hljs-keyword">struct</span> AdjVNode{
    Vertex AdjV;        <span class="hljs-comment">/* 邻接点下标 */</span>
    WeightType Weight;  <span class="hljs-comment">/* 边权重 */</span>
    PtrToAdjVNode Next;    <span class="hljs-comment">/* 指向下一个邻接点的指针 */</span>
};
 
<span class="hljs-comment">/* 顶点表头结点的定义 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Vnode{
    PtrToAdjVNode FirstEdge;<span class="hljs-comment">/* 边表头指针 */</span>
    DataType Data;            <span class="hljs-comment">/* 存顶点的数据 */</span>
    <span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span>
} AdjList[MaxVertexNum];    <span class="hljs-comment">/* AdjList是邻接表类型 */</span>
 
<span class="hljs-comment">/* 图结点的定义 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> GNode *PtrToGNode;
<span class="hljs-keyword">struct</span> GNode{  
    <span class="hljs-keyword">int</span> Nv;     <span class="hljs-comment">/* 顶点数 */</span>
    <span class="hljs-keyword">int</span> Ne;     <span class="hljs-comment">/* 边数   */</span>
    AdjList G;  <span class="hljs-comment">/* 邻接表 */</span>
};
<span class="hljs-keyword">typedef</span> PtrToGNode LGraph; <span class="hljs-comment">/* 以邻接表方式存储的图类型 */</span>
 
 
 
<span class="hljs-function">LGraph <span class="hljs-title">CreateGraph</span><span class="hljs-params">( <span class="hljs-keyword">int</span> VertexNum )</span>
</span>{ <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>
    Vertex V;
    LGraph Graph;
     
    Graph = (LGraph)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode) ); <span class="hljs-comment">/* 建立图 */</span>
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* 初始化邻接表头指针 */</span>
    <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>
       <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)
        Graph-&gt;G[V].FirstEdge = <span class="hljs-literal">NULL</span>;
             
    <span class="hljs-keyword">return</span> Graph; 
}
        
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">( LGraph Graph, Edge E )</span>
</span>{
    PtrToAdjVNode NewNode;
     
    <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>
    <span class="hljs-comment">/* 为V2建立新的邻接点 */</span>
    NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));
    NewNode-&gt;AdjV = E-&gt;V2;
    NewNode-&gt;Weight = E-&gt;Weight;
    <span class="hljs-comment">/* 将V2插入V1的表头 */</span>
    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;
    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;
         
    <span class="hljs-comment">/* 若是无向图，还要插入边 &lt;V2, V1&gt; */</span>
    <span class="hljs-comment">/* 为V1建立新的邻接点 */</span>
    NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));
    NewNode-&gt;AdjV = E-&gt;V1;
    NewNode-&gt;Weight = E-&gt;Weight;
    <span class="hljs-comment">/* 将V1插入V2的表头 */</span>
    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;
    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;
}
 
<span class="hljs-function">LGraph <span class="hljs-title">BuildGraph</span><span class="hljs-params">()</span>
</span>{
    LGraph Graph;
    Edge E;
    Vertex V;
    <span class="hljs-keyword">int</span> Nv, i;
     
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>
    Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span> 
     
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>
    <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) { <span class="hljs-comment">/* 如果有边 */</span> 
        E = (Edge)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode) ); <span class="hljs-comment">/* 建立边结点 */</span> 
        <span class="hljs-comment">/* 读入边，格式为"起点 终点 权重"，插入邻接矩阵 */</span>
        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); 
            <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>
            InsertEdge( Graph, E );
        }
    } 
 
    <span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) 
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;(Graph-&gt;G[V].Data));
 
    <span class="hljs-keyword">return</span> Graph;
}
</code></pre>
<p><strong>图的遍历</strong></p>
<pre><code class="language-c">/* 邻接表存储的图 - DFS */
 
void Visit( Vertex V )
{
    printf("正在访问顶点%d\n", V);
}
 
/* Visited[]为全局变量，已经初始化为false */
void DFS( LGraph Graph, Vertex V, void (*Visit)(Vertex) )
{   /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */
    PtrToAdjVNode W;
     
    Visit( V ); /* 访问第V个顶点 */
    Visited[V] = true; /* 标记V已访问 */
 
    for( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */
        if ( !Visited[W-&gt;AdjV] )    /* 若W-&gt;AdjV未被访问 */
            DFS( Graph, W-&gt;AdjV, Visit );    /* 则递归访问之 */
}
</code></pre>
<pre><code class="language-c">/* 邻接矩阵存储的图 - BFS */
 
/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */
/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/
/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */
bool IsEdge( MGraph Graph, Vertex V, Vertex W )
{
    return Graph-&gt;G[V][W]&lt;INFINITY ? true : false;
}
 
/* Visited[]为全局变量，已经初始化为false */
void BFS ( MGraph Graph, Vertex S, void (*Visit)(Vertex) )
{   /* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */
    Queue Q;     
    Vertex V, W;
 
    Q = CreateQueue( MaxSize ); /* 创建空队列, MaxSize为外部定义的常数 */
    /* 访问顶点S：此处可根据具体访问需要改写 */
    Visit( S );
    Visited[S] = true; /* 标记S已访问 */
    AddQ(Q, S); /* S入队列 */
     
    while ( !IsEmpty(Q) ) {
        V = DeleteQ(Q);  /* 弹出V */
        for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */
            /* 若W是V的邻接点并且未访问过 */
            if ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) {
                /* 访问顶点W */
                Visit( W );
                Visited[W] = true; /* 标记W已访问 */
                AddQ(Q, W); /* W入队列 */
            }
    } /* while结束*/
}
</code></pre>
<p><strong>最短路径问题</strong></p>
<pre><code class="language-c"><span class="hljs-comment">/* 邻接表存储 - 无权图的单源最短路算法 */</span>
 
<span class="hljs-comment">/* dist[]和path[]全部初始化为-1 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unweighted</span> <span class="hljs-params">( LGraph Graph, <span class="hljs-keyword">int</span> dist[], <span class="hljs-keyword">int</span> path[], Vertex S )</span>
</span>{
    Queue Q;
    Vertex V;
    PtrToAdjVNode W;
     
    Q = CreateQueue( Graph-&gt;Nv ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>
    dist[S] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始化源点 */</span>
    AddQ (Q, S);
 
    <span class="hljs-keyword">while</span>( !IsEmpty(Q) ){
        V = DeleteQ(Q);
        <span class="hljs-keyword">for</span> ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>
            <span class="hljs-keyword">if</span> ( dist[W-&gt;AdjV]==-<span class="hljs-number">1</span> ) { <span class="hljs-comment">/* 若W-&gt;AdjV未被访问过 */</span>
                dist[W-&gt;AdjV] = dist[V]+<span class="hljs-number">1</span>; <span class="hljs-comment">/* W-&gt;AdjV到S的距离更新 */</span>
                path[W-&gt;AdjV] = V; <span class="hljs-comment">/* 将V记录在S到W-&gt;AdjV的路径上 */</span>
                AddQ(Q, W-&gt;AdjV);
            }
    } <span class="hljs-comment">/* while结束*/</span>
}
</code></pre>
<pre><code class="language-c"><span class="hljs-comment">/* 邻接矩阵存储 - 有权图的单源最短路算法 */</span>
 
<span class="hljs-function">Vertex <span class="hljs-title">FindMinDist</span><span class="hljs-params">( MGraph Graph, <span class="hljs-keyword">int</span> dist[], <span class="hljs-keyword">int</span> collected[] )</span>
</span>{ <span class="hljs-comment">/* 返回未被收录顶点中dist最小者 */</span>
    Vertex MinV, V;
    <span class="hljs-keyword">int</span> MinDist = INFINITY;
 
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) {
        <span class="hljs-keyword">if</span> ( collected[V]==<span class="hljs-literal">false</span> &amp;&amp; dist[V]&lt;MinDist) {
            <span class="hljs-comment">/* 若V未被收录，且dist[V]更小 */</span>
            MinDist = dist[V]; <span class="hljs-comment">/* 更新最小距离 */</span>
            MinV = V; <span class="hljs-comment">/* 更新对应顶点 */</span>
        }
    }
    <span class="hljs-keyword">if</span> (MinDist &lt; INFINITY) <span class="hljs-comment">/* 若找到最小dist */</span>
        <span class="hljs-keyword">return</span> MinV; <span class="hljs-comment">/* 返回对应的顶点下标 */</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">/* 若这样的顶点不存在，返回错误标记 */</span>
}
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">( MGraph Graph, <span class="hljs-keyword">int</span> dist[], <span class="hljs-keyword">int</span> path[], Vertex S )</span>
</span>{
    <span class="hljs-keyword">int</span> collected[MaxVertexNum];
    Vertex V, W;
 
    <span class="hljs-comment">/* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 */</span>
    <span class="hljs-keyword">for</span> ( V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++ ) {
        dist[V] = Graph-&gt;G[S][V];
        <span class="hljs-keyword">if</span> ( dist[V]&lt;INFINITY )
            path[V] = S;
        <span class="hljs-keyword">else</span>
            path[V] = -<span class="hljs-number">1</span>;
        collected[V] = <span class="hljs-literal">false</span>;
    }
    <span class="hljs-comment">/* 先将起点收入集合 */</span>
    dist[S] = <span class="hljs-number">0</span>;
    collected[S] = <span class="hljs-literal">true</span>;
 
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-comment">/* V = 未被收录顶点中dist最小者 */</span>
        V = FindMinDist( Graph, dist, collected );
        <span class="hljs-keyword">if</span> ( V==ERROR ) <span class="hljs-comment">/* 若这样的V不存在 */</span>
            <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 算法结束 */</span>
        collected[V] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">/* 收录V */</span>
        <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>
            <span class="hljs-comment">/* 若W是V的邻接点并且未被收录 */</span>
            <span class="hljs-keyword">if</span> ( collected[W]==<span class="hljs-literal">false</span> &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) {
                <span class="hljs-keyword">if</span> ( Graph-&gt;G[V][W]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若有负边 */</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>
                <span class="hljs-comment">/* 若收录V使得dist[W]变小 */</span>
                <span class="hljs-keyword">if</span> ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) {
                    dist[W] = dist[V]+Graph-&gt;G[V][W]; <span class="hljs-comment">/* 更新dist[W] */</span>
                    path[W] = V; <span class="hljs-comment">/* 更新S到W的路径 */</span>
                }
            }
    } <span class="hljs-comment">/* while结束*/</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span>
}
</code></pre>
<pre><code class="language-c"><span class="hljs-comment">/* 邻接矩阵存储 - 多源最短路算法 */</span>
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Floyd</span><span class="hljs-params">( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )</span>
</span>{
    Vertex i, j, k;
 
    <span class="hljs-comment">/* 初始化 */</span>
    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )
        <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ ) {
            D[i][j] = Graph-&gt;G[i][j];
            path[i][j] = -<span class="hljs-number">1</span>;
        }
 
    <span class="hljs-keyword">for</span>( k=<span class="hljs-number">0</span>; k&lt;Graph-&gt;Nv; k++ )
        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )
            <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ )
                <span class="hljs-keyword">if</span>( D[i][k] + D[k][j] &lt; D[i][j] ) {
                    D[i][j] = D[i][k] + D[k][j];
                    <span class="hljs-keyword">if</span> ( i==j &amp;&amp; D[i][j]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若发现负值圈 */</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>
                    path[i][j] = k;
                }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span>
}
</code></pre>
<p><strong>最小生成树</strong></p>
<pre><code class="language-c"><span class="hljs-comment">/* 邻接矩阵存储 - Prim最小生成树算法 */</span>
 
<span class="hljs-function">Vertex <span class="hljs-title">FindMinDist</span><span class="hljs-params">( MGraph Graph, WeightType dist[] )</span>
</span>{ <span class="hljs-comment">/* 返回未被收录顶点中dist最小者 */</span>
    Vertex MinV, V;
    WeightType MinDist = INFINITY;
 
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) {
        <span class="hljs-keyword">if</span> ( dist[V]!=<span class="hljs-number">0</span> &amp;&amp; dist[V]&lt;MinDist) {
            <span class="hljs-comment">/* 若V未被收录，且dist[V]更小 */</span>
            MinDist = dist[V]; <span class="hljs-comment">/* 更新最小距离 */</span>
            MinV = V; <span class="hljs-comment">/* 更新对应顶点 */</span>
        }
    }
    <span class="hljs-keyword">if</span> (MinDist &lt; INFINITY) <span class="hljs-comment">/* 若找到最小dist */</span>
        <span class="hljs-keyword">return</span> MinV; <span class="hljs-comment">/* 返回对应的顶点下标 */</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">/* 若这样的顶点不存在，返回-1作为标记 */</span>
}
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">( MGraph Graph, LGraph MST )</span>
</span>{ <span class="hljs-comment">/* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */</span>
    WeightType dist[MaxVertexNum], TotalWeight;
    Vertex parent[MaxVertexNum], V, W;
    <span class="hljs-keyword">int</span> VCount;
    Edge E;
     
    <span class="hljs-comment">/* 初始化。默认初始点下标是0 */</span>
       <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) {
        <span class="hljs-comment">/* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY */</span>
           dist[V] = Graph-&gt;G[<span class="hljs-number">0</span>][V];
           parent[V] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 暂且定义所有顶点的父结点都是初始点0 */</span> 
    }
    TotalWeight = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始化权重和     */</span>
    VCount = <span class="hljs-number">0</span>;      <span class="hljs-comment">/* 初始化收录的顶点数 */</span>
    <span class="hljs-comment">/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */</span>
    MST = CreateGraph(Graph-&gt;Nv);
    E = (Edge)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode) ); <span class="hljs-comment">/* 建立空的边结点 */</span>
            
    <span class="hljs-comment">/* 将初始点0收录进MST */</span>
    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    VCount ++;
    parent[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">/* 当前树根是0 */</span>
 
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        V = FindMinDist( Graph, dist );
        <span class="hljs-comment">/* V = 未被收录顶点中dist最小者 */</span>
        <span class="hljs-keyword">if</span> ( V==ERROR ) <span class="hljs-comment">/* 若这样的V不存在 */</span>
            <span class="hljs-keyword">break</span>;   <span class="hljs-comment">/* 算法结束 */</span>
             
        <span class="hljs-comment">/* 将V及相应的边&lt;parent[V], V&gt;收录进MST */</span>
        E-&gt;V1 = parent[V];
        E-&gt;V2 = V;
        E-&gt;Weight = dist[V];
        InsertEdge( MST, E );
        TotalWeight += dist[V];
        dist[V] = <span class="hljs-number">0</span>;
        VCount++;
         
        <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>
            <span class="hljs-keyword">if</span> ( dist[W]!=<span class="hljs-number">0</span> &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) {
            <span class="hljs-comment">/* 若W是V的邻接点并且未被收录 */</span>
                <span class="hljs-keyword">if</span> ( Graph-&gt;G[V][W] &lt; dist[W] ) {
                <span class="hljs-comment">/* 若收录V使得dist[W]变小 */</span>
                    dist[W] = Graph-&gt;G[V][W]; <span class="hljs-comment">/* 更新dist[W] */</span>
                    parent[W] = V; <span class="hljs-comment">/* 更新树 */</span>
                }
            }
    } <span class="hljs-comment">/* while结束*/</span>
    <span class="hljs-keyword">if</span> ( VCount &lt; Graph-&gt;Nv ) <span class="hljs-comment">/* MST中收的顶点不到|V|个 */</span>
       TotalWeight = ERROR;
    <span class="hljs-keyword">return</span> TotalWeight;   <span class="hljs-comment">/* 算法执行完毕，返回最小权重和或错误标记 */</span>
}
</code></pre>
<pre><code class="language-c"><span class="hljs-comment">/* 邻接表存储 - Kruskal最小生成树算法 */</span>
 
<span class="hljs-comment">/*-------------------- 顶点并查集定义 --------------------*/</span>
<span class="hljs-keyword">typedef</span> Vertex ElementType; <span class="hljs-comment">/* 默认元素可以用非负整数表示 */</span>
<span class="hljs-keyword">typedef</span> Vertex SetName;     <span class="hljs-comment">/* 默认用根结点的下标作为集合名称 */</span>
<span class="hljs-keyword">typedef</span> ElementType SetType[MaxVertexNum]; <span class="hljs-comment">/* 假设集合元素下标从0开始 */</span>
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitializeVSet</span><span class="hljs-params">( SetType S, <span class="hljs-keyword">int</span> N )</span>
</span>{ <span class="hljs-comment">/* 初始化并查集 */</span>
    ElementType X;
 
    <span class="hljs-keyword">for</span> ( X=<span class="hljs-number">0</span>; X&lt;N; X++ ) S[X] = -<span class="hljs-number">1</span>;
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2 )</span>
</span>{ <span class="hljs-comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span>
    <span class="hljs-comment">/* 保证小集合并入大集合 */</span>
    <span class="hljs-keyword">if</span> ( S[Root2] &lt; S[Root1] ) { <span class="hljs-comment">/* 如果集合2比较大 */</span>
        S[Root2] += S[Root1];     <span class="hljs-comment">/* 集合1并入集合2  */</span>
        S[Root1] = Root2;
    }
    <span class="hljs-keyword">else</span> {                         <span class="hljs-comment">/* 如果集合1比较大 */</span>
        S[Root1] += S[Root2];     <span class="hljs-comment">/* 集合2并入集合1  */</span>
        S[Root2] = Root1;
    }
}
 
<span class="hljs-function">SetName <span class="hljs-title">Find</span><span class="hljs-params">( SetType S, ElementType X )</span>
</span>{ <span class="hljs-comment">/* 默认集合元素全部初始化为-1 */</span>
    <span class="hljs-keyword">if</span> ( S[X] &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">/* 找到集合的根 */</span>
        <span class="hljs-keyword">return</span> X;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> S[X] = Find( S, S[X] ); <span class="hljs-comment">/* 路径压缩 */</span>
}
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckCycle</span><span class="hljs-params">( SetType VSet, Vertex V1, Vertex V2 )</span>
</span>{ <span class="hljs-comment">/* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */</span>
    Vertex Root1, Root2;
 
    Root1 = Find( VSet, V1 ); <span class="hljs-comment">/* 得到V1所属的连通集名称 */</span>
    Root2 = Find( VSet, V2 ); <span class="hljs-comment">/* 得到V2所属的连通集名称 */</span>
 
    <span class="hljs-keyword">if</span>( Root1==Root2 ) <span class="hljs-comment">/* 若V1和V2已经连通，则该边不能要 */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 否则该边可以被收集，同时将V1和V2并入同一连通集 */</span>
        Union( VSet, Root1, Root2 );
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
<span class="hljs-comment">/*-------------------- 并查集定义结束 --------------------*/</span>
 
<span class="hljs-comment">/*-------------------- 边的最小堆定义 --------------------*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PercDown</span><span class="hljs-params">( Edge ESet, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> N )</span>
</span>{ <span class="hljs-comment">/* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span>
  <span class="hljs-comment">/* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */</span>
    <span class="hljs-keyword">int</span> Parent, Child;
    <span class="hljs-keyword">struct</span> ENode X;
 
    X = ESet[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span>
    <span class="hljs-keyword">for</span>( Parent=p; (Parent*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&lt;N; Parent=Child ) {
        Child = Parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>( (Child!=N-<span class="hljs-number">1</span>) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+<span class="hljs-number">1</span>].Weight) )
            Child++;  <span class="hljs-comment">/* Child指向左右子结点的较小者 */</span>
        <span class="hljs-keyword">if</span>( X.Weight &lt;= ESet[Child].Weight ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>
        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>
            ESet[Parent] = ESet[Child];
    }
    ESet[Parent] = X;
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitializeESet</span><span class="hljs-params">( LGraph Graph, Edge ESet )</span>
</span>{ <span class="hljs-comment">/* 将图的边存入数组ESet，并且初始化为最小堆 */</span>
    Vertex V;
    PtrToAdjVNode W;
    <span class="hljs-keyword">int</span> ECount;
 
    <span class="hljs-comment">/* 将图的边存入数组ESet */</span>
    ECount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> ( V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++ )
        <span class="hljs-keyword">for</span> ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next )
            <span class="hljs-keyword">if</span> ( V &lt; W-&gt;AdjV ) { <span class="hljs-comment">/* 避免重复录入无向图的边，只收V1&lt;V2的边 */</span>
                ESet[ECount].V1 = V;
                ESet[ECount].V2 = W-&gt;AdjV;
                ESet[ECount++].Weight = W-&gt;Weight;
            }
    <span class="hljs-comment">/* 初始化为最小堆 */</span>
    <span class="hljs-keyword">for</span> ( ECount=Graph-&gt;Ne/<span class="hljs-number">2</span>; ECount&gt;=<span class="hljs-number">0</span>; ECount-- )
        PercDown( ESet, ECount, Graph-&gt;Ne );
}
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetEdge</span><span class="hljs-params">( Edge ESet, <span class="hljs-keyword">int</span> CurrentSize )</span>
</span>{ <span class="hljs-comment">/* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */</span>
 
    <span class="hljs-comment">/* 将最小边与当前堆的最后一个位置的边交换 */</span>
    Swap( &amp;ESet[<span class="hljs-number">0</span>], &amp;ESet[CurrentSize-<span class="hljs-number">1</span>]);
    <span class="hljs-comment">/* 将剩下的边继续调整成最小堆 */</span>
    PercDown( ESet, <span class="hljs-number">0</span>, CurrentSize-<span class="hljs-number">1</span> );
 
    <span class="hljs-keyword">return</span> CurrentSize-<span class="hljs-number">1</span>; <span class="hljs-comment">/* 返回最小边所在位置 */</span>
}
<span class="hljs-comment">/*-------------------- 最小堆定义结束 --------------------*/</span>
 
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">( LGraph Graph, LGraph MST )</span>
</span>{ <span class="hljs-comment">/* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */</span>
    WeightType TotalWeight;
    <span class="hljs-keyword">int</span> ECount, NextEdge;
    SetType VSet; <span class="hljs-comment">/* 顶点数组 */</span>
    Edge ESet;    <span class="hljs-comment">/* 边数组 */</span>
 
    InitializeVSet( VSet, Graph-&gt;Nv ); <span class="hljs-comment">/* 初始化顶点并查集 */</span>
    ESet = (Edge)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)*Graph-&gt;Ne );
    InitializeESet( Graph, ESet ); <span class="hljs-comment">/* 初始化边的最小堆 */</span>
    <span class="hljs-comment">/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */</span>
    MST = CreateGraph(Graph-&gt;Nv);
    TotalWeight = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始化权重和     */</span>
    ECount = <span class="hljs-number">0</span>;      <span class="hljs-comment">/* 初始化收录的边数 */</span>
 
    NextEdge = Graph-&gt;Ne; <span class="hljs-comment">/* 原始边集的规模 */</span>
    <span class="hljs-keyword">while</span> ( ECount &lt; Graph-&gt;Nv-<span class="hljs-number">1</span> ) {  <span class="hljs-comment">/* 当收集的边不足以构成树时 */</span>
        NextEdge = GetEdge( ESet, NextEdge ); <span class="hljs-comment">/* 从边集中得到最小边的位置 */</span>
        <span class="hljs-keyword">if</span> (NextEdge &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">/* 边集已空 */</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">/* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */</span>
        <span class="hljs-keyword">if</span> ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )==<span class="hljs-literal">true</span> ) {
            <span class="hljs-comment">/* 将该边插入MST */</span>
            InsertEdge( MST, ESet+NextEdge );
            TotalWeight += ESet[NextEdge].Weight; <span class="hljs-comment">/* 累计权重 */</span>
            ECount++; <span class="hljs-comment">/* 生成树中边数加1 */</span>
        }
    }
    <span class="hljs-keyword">if</span> ( ECount &lt; Graph-&gt;Nv-<span class="hljs-number">1</span> )
        TotalWeight = -<span class="hljs-number">1</span>; <span class="hljs-comment">/* 设置错误标记，表示生成树不存在 */</span>
 
    <span class="hljs-keyword">return</span> TotalWeight;
}
</code></pre>
<p><strong>拓扑排序</strong></p>
<pre><code class="language-c"><span class="hljs-comment">/* 邻接表存储 - 拓扑排序算法 */</span>
 
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TopSort</span><span class="hljs-params">( LGraph Graph, Vertex TopOrder[] )</span>
</span>{ <span class="hljs-comment">/* 对Graph进行拓扑排序,  TopOrder[]顺序存储排序后的顶点下标 */</span>
    <span class="hljs-keyword">int</span> Indegree[MaxVertexNum], cnt;
    Vertex V;
    PtrToAdjVNode W;
       Queue Q = CreateQueue( Graph-&gt;Nv );
  
    <span class="hljs-comment">/* 初始化Indegree[] */</span>
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)
        Indegree[V] = <span class="hljs-number">0</span>;
         
    <span class="hljs-comment">/* 遍历图，得到Indegree[] */</span>
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)
        <span class="hljs-keyword">for</span> (W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next)
            Indegree[W-&gt;AdjV]++; <span class="hljs-comment">/* 对有向边&lt;V, W-&gt;AdjV&gt;累计终点的入度 */</span>
             
    <span class="hljs-comment">/* 将所有入度为0的顶点入列 */</span>
    <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)
        <span class="hljs-keyword">if</span> ( Indegree[V]==<span class="hljs-number">0</span> )
            AddQ(Q, V);
             
    <span class="hljs-comment">/* 下面进入拓扑排序 */</span> 
    cnt = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">while</span>( !IsEmpty(Q) ){
        V = DeleteQ(Q); <span class="hljs-comment">/* 弹出一个入度为0的顶点 */</span>
        TopOrder[cnt++] = V; <span class="hljs-comment">/* 将之存为结果序列的下一个元素 */</span>
        <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>
        <span class="hljs-keyword">for</span> ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next )
            <span class="hljs-keyword">if</span> ( --Indegree[W-&gt;AdjV] == <span class="hljs-number">0</span> )<span class="hljs-comment">/* 若删除V使得W-&gt;AdjV入度为0 */</span>
                AddQ(Q, W-&gt;AdjV); <span class="hljs-comment">/* 则该顶点入列 */</span> 
    } <span class="hljs-comment">/* while结束*/</span>
     
    <span class="hljs-keyword">if</span> ( cnt != Graph-&gt;Nv )
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 说明图中有回路, 返回不成功标志 */</span> 
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p><strong>插入排序</strong></p>
<pre><code class="language-c">void InsertionSort( ElementType A[], int N )
{ /* 插入排序 */
     int P, i;
     ElementType Tmp;
      
     for ( P=1; P&lt;N; P++ ) {
         Tmp = A[P]; /* 取出未排序序列中的第一个元素*/
         for ( i=P; i&gt;0 &amp;&amp; A[i-1]&gt;Tmp; i-- )
             A[i] = A[i-1]; /*依次与已排序序列中元素比较并右移*/
         A[i] = Tmp; /* 放进合适的位置 */
     }
}



void ShellSort( ElementType A[], int N )
{ /* 希尔排序 - 用Sedgewick增量序列 */
     int Si, D, P, i;
     ElementType Tmp;
     /* 这里只列出一小部分增量 */
     int Sedgewick[] = {929, 505, 209, 109, 41, 19, 5, 1, 0};
      
     for ( Si=0; Sedgewick[Si]&gt;=N; Si++ ) 
         ; /* 初始的增量Sedgewick[Si]不能超过待排序列长度 */
 
     for ( D=Sedgewick[Si]; D&gt;0; D=Sedgewick[++Si] )
         for ( P=D; P&lt;N; P++ ) { /* 插入排序*/
             Tmp = A[P];
             for ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )
                 A[i] = A[i-D];
             A[i] = Tmp;
         }
}
void Swap( ElementType *a, ElementType *b )
{
     ElementType t = *a; *a = *b; *b = t;
}
  
void PercDown( ElementType A[], int p, int N )
{ /* 改编代码4.24的PercDown( MaxHeap H, int p )    */
  /* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */
    int Parent, Child;
    ElementType X;
 
    X = A[p]; /* 取出根结点存放的值 */
    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) {
        Child = Parent * 2 + 1;
        if( (Child!=N-1) &amp;&amp; (A[Child]&lt;A[Child+1]) )
            Child++;  /* Child指向左右子结点的较大者 */
        if( X &gt;= A[Child] ) break; /* 找到了合适位置 */
        else  /* 下滤X */
            A[Parent] = A[Child];
    }
    A[Parent] = X;
}
 
void HeapSort( ElementType A[], int N ) 
{ /* 堆排序 */
     int i;
       
     for ( i=N/2-1; i&gt;=0; i-- )/* 建立最大堆 */
         PercDown( A, i, N );
      
     for ( i=N-1; i&gt;0; i-- ) {
         /* 删除最大堆顶 */
         Swap( &amp;A[0], &amp;A[i] ); /* 见代码7.1 */
         PercDown( A, 0, i );
     }
}



/* 归并排序 - 递归实现 */
/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/
void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd )
{ /* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */
     int LeftEnd, NumElements, Tmp;
     int i;
      
     LeftEnd = R - 1; /* 左边终点位置 */
     Tmp = L;         /* 有序序列的起始位置 */
     NumElements = RightEnd - L + 1;
      
     while( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) {
         if ( A[L] &lt;= A[R] )
             TmpA[Tmp++] = A[L++]; /* 将左边元素复制到TmpA */
         else
             TmpA[Tmp++] = A[R++]; /* 将右边元素复制到TmpA */
     }
 
     while( L &lt;= LeftEnd )
         TmpA[Tmp++] = A[L++]; /* 直接复制左边剩下的 */
     while( R &lt;= RightEnd )
         TmpA[Tmp++] = A[R++]; /* 直接复制右边剩下的 */
          
     for( i = 0; i &lt; NumElements; i++, RightEnd -- )
         A[RightEnd] = TmpA[RightEnd]; /* 将有序的TmpA[]复制回A[] */
}
 
 
 
void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd )
{ /* 核心递归排序函数 */ 
     int Center;
      
     if ( L &lt; RightEnd ) {
          Center = (L+RightEnd) / 2;
          Msort( A, TmpA, L, Center );              /* 递归解决左边 */ 
          Msort( A, TmpA, Center+1, RightEnd );     /* 递归解决右边 */  
          Merge( A, TmpA, L, Center+1, RightEnd );  /* 合并两段有序序列 */ 
     }
}
void MergeSort( ElementType A[], int N )
{ /* 归并排序 */
     ElementType *TmpA;
     TmpA = (ElementType *)malloc(N*sizeof(ElementType));
      
     if ( TmpA != NULL ) {
          Msort( A, TmpA, 0, N-1 );
          free( TmpA );
     }
     else printf( "空间不足" );
}




/* 归并排序 - 循环实现 */
/* 这里Merge函数在递归版本中给出 */
 
/* length = 当前有序子列的长度*/
void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length )
{ /* 两两归并相邻有序子列 */
     int i, j;
       
     for ( i=0; i &lt;= N-2*length; i += 2*length )
         Merge( A, TmpA, i, i+length, i+2*length-1 );
     if ( i+length &lt; N ) /* 归并最后2个子列*/
         Merge( A, TmpA, i, i+length, N-1);
     else /* 最后只剩1个子列*/
         for ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];
}
 
void Merge_Sort( ElementType A[], int N )
{ 
     int length; 
     ElementType *TmpA;
      
     length = 1; /* 初始化子序列长度*/
     TmpA = malloc( N * sizeof( ElementType ) );
     if ( TmpA != NULL ) {
          while( length &lt; N ) {
              Merge_pass( A, TmpA, N, length );
              length *= 2;
              Merge_pass( TmpA, A, N, length );
              length *= 2;
          }
          free( TmpA );
     }
     else printf( "空间不足" );
}


</code></pre>
<p><strong>快速排序</strong></p>
<pre><code class="language-c"><span class="hljs-comment">/* 快速排序 - 直接调用库函数 */</span>
 
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
 
<span class="hljs-comment">/*---------------简单整数排序--------------------*/</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *b)</span>
</span>{ <span class="hljs-comment">/* 比较两整数。非降序排列 */</span>
    <span class="hljs-keyword">return</span> (*(<span class="hljs-keyword">int</span>*)a - *(<span class="hljs-keyword">int</span>*)b);
}
<span class="hljs-comment">/* 调用接口 */</span> 
qsort(A, N, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), compare);
<span class="hljs-comment">/*---------------简单整数排序--------------------*/</span>
 
 
<span class="hljs-comment">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span>
<span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> key1, key2;
} A[MAXN];
  
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare2keys</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *b)</span>
</span>{ <span class="hljs-comment">/* 比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列 */</span>
    <span class="hljs-keyword">int</span> k;
    <span class="hljs-keyword">if</span> ( ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> Node*)a)-&gt;key1 &lt; ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> Node*)b)-&gt;key1 )
        k = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> Node*)a)-&gt;key1 &gt; ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> Node*)b)-&gt;key1 )
        k = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 如果key1相等 */</span>
        <span class="hljs-keyword">if</span> ( ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> Node*)a)-&gt;key2 &lt; ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> Node*)b)-&gt;key2 )
            k = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            k = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> k;
}
<span class="hljs-comment">/* 调用接口 */</span> 
qsort(A, N, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node), compare2keys);
<span class="hljs-comment">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span>







<span class="hljs-comment">/* 快速排序 */</span>
 
<span class="hljs-function">ElementType <span class="hljs-title">Median3</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right )</span>
</span>{ 
    <span class="hljs-keyword">int</span> Center = (Left+Right) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span> ( A[Left] &gt; A[Center] )
        Swap( &amp;A[Left], &amp;A[Center] );
    <span class="hljs-keyword">if</span> ( A[Left] &gt; A[Right] )
        Swap( &amp;A[Left], &amp;A[Right] );
    <span class="hljs-keyword">if</span> ( A[Center] &gt; A[Right] )
        Swap( &amp;A[Center], &amp;A[Right] );
    <span class="hljs-comment">/* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span>
    Swap( &amp;A[Center], &amp;A[Right-<span class="hljs-number">1</span>] ); <span class="hljs-comment">/* 将基准Pivot藏到右边*/</span>
    <span class="hljs-comment">/* 只需要考虑A[Left+1] … A[Right-2] */</span>
    <span class="hljs-keyword">return</span>  A[Right-<span class="hljs-number">1</span>];  <span class="hljs-comment">/* 返回基准Pivot */</span>
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Qsort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right )</span>
</span>{ <span class="hljs-comment">/* 核心递归函数 */</span> 
     <span class="hljs-keyword">int</span> Pivot, Cutoff, Low, High;
       
     <span class="hljs-keyword">if</span> ( Cutoff &lt;= Right-Left ) { <span class="hljs-comment">/* 如果序列元素充分多，进入快排 */</span>
          Pivot = Median3( A, Left, Right ); <span class="hljs-comment">/* 选基准 */</span> 
          Low = Left; High = Right-<span class="hljs-number">1</span>;
          <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) { <span class="hljs-comment">/*将序列中比基准小的移到基准左边，大的移到右边*/</span>
               <span class="hljs-keyword">while</span> ( A[++Low] &lt; Pivot ) ;
               <span class="hljs-keyword">while</span> ( A[--High] &gt; Pivot ) ;
               <span class="hljs-keyword">if</span> ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );
               <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
          }
          Swap( &amp;A[Low], &amp;A[Right-<span class="hljs-number">1</span>] );   <span class="hljs-comment">/* 将基准换到正确的位置 */</span> 
          Qsort( A, Left, Low-<span class="hljs-number">1</span> );    <span class="hljs-comment">/* 递归解决左边 */</span> 
          Qsort( A, Low+<span class="hljs-number">1</span>, Right );   <span class="hljs-comment">/* 递归解决右边 */</span>  
     }
     <span class="hljs-keyword">else</span> InsertionSort( A+Left, Right-Left+<span class="hljs-number">1</span> ); <span class="hljs-comment">/* 元素太少，用简单排序 */</span> 
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span>
</span>{ <span class="hljs-comment">/* 统一接口 */</span>
     Qsort( A, <span class="hljs-number">0</span>, N-<span class="hljs-number">1</span> );
}
</code></pre>
<p><strong>基数排序</strong></p>
<pre><code class="language-c"><span class="hljs-comment">/* 基数排序 - 次位优先 */</span>
 
<span class="hljs-comment">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MaxDigit <span class="hljs-number">4</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Radix <span class="hljs-number">10</span></span>
 
<span class="hljs-comment">/* 桶元素结点 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Node *PtrToNode;
<span class="hljs-keyword">struct</span> Node {
    <span class="hljs-keyword">int</span> key;
    PtrToNode next;
};
 
<span class="hljs-comment">/* 桶头结点 */</span>
<span class="hljs-keyword">struct</span> HeadNode {
    PtrToNode head, tail;
};
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> HeadNode Bucket[Radix];
  
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetDigit</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> D )</span>
</span>{ <span class="hljs-comment">/* 默认次位D=1, 主位D&lt;=MaxDigit */</span>
    <span class="hljs-keyword">int</span> d, i;
     
    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=D; i++) {
        d = X % Radix;
        X /= Radix;
    }
    <span class="hljs-keyword">return</span> d;
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LSDRadixSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span>
</span>{ <span class="hljs-comment">/* 基数排序 - 次位优先 */</span>
     <span class="hljs-keyword">int</span> D, Di, i;
     Bucket B;
     PtrToNode tmp, p, List = <span class="hljs-literal">NULL</span>; 
      
     <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Radix; i++) <span class="hljs-comment">/* 初始化每个桶为空链表 */</span>
         B[i].head = B[i].tail = <span class="hljs-literal">NULL</span>;
     <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) { <span class="hljs-comment">/* 将原始序列逆序存入初始链表List */</span>
         tmp = (PtrToNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));
         tmp-&gt;key = A[i];
         tmp-&gt;next = List;
         List = tmp;
     }
     <span class="hljs-comment">/* 下面开始排序 */</span> 
     <span class="hljs-keyword">for</span> (D=<span class="hljs-number">1</span>; D&lt;=MaxDigit; D++) { <span class="hljs-comment">/* 对数据的每一位循环处理 */</span>
         <span class="hljs-comment">/* 下面是分配的过程 */</span>
         p = List;
         <span class="hljs-keyword">while</span> (p) {
             Di = GetDigit(p-&gt;key, D); <span class="hljs-comment">/* 获得当前元素的当前位数字 */</span>
             <span class="hljs-comment">/* 从List中摘除 */</span>
             tmp = p; p = p-&gt;next;
             <span class="hljs-comment">/* 插入B[Di]号桶尾 */</span>
             tmp-&gt;next = <span class="hljs-literal">NULL</span>;
             <span class="hljs-keyword">if</span> (B[Di].head == <span class="hljs-literal">NULL</span>)
                 B[Di].head = B[Di].tail = tmp;
             <span class="hljs-keyword">else</span> {
                 B[Di].tail-&gt;next = tmp;
                 B[Di].tail = tmp;
             }
         }
         <span class="hljs-comment">/* 下面是收集的过程 */</span>
         List = <span class="hljs-literal">NULL</span>; 
         <span class="hljs-keyword">for</span> (Di=Radix-<span class="hljs-number">1</span>; Di&gt;=<span class="hljs-number">0</span>; Di--) { <span class="hljs-comment">/* 将每个桶的元素顺序收集入List */</span>
             <span class="hljs-keyword">if</span> (B[Di].head) { <span class="hljs-comment">/* 如果桶不为空 */</span>
                 <span class="hljs-comment">/* 整桶插入List表头 */</span>
                 B[Di].tail-&gt;next = List;
                 List = B[Di].head;
                 B[Di].head = B[Di].tail = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 清空桶 */</span>
             }
         }
     }
     <span class="hljs-comment">/* 将List倒入A[]并释放空间 */</span>
     <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) {
        tmp = List;
        List = List-&gt;next;
        A[i] = tmp-&gt;key;
        <span class="hljs-built_in">free</span>(tmp);
     } 
}


<span class="hljs-comment">/* 基数排序 - 主位优先 */</span>
 
<span class="hljs-comment">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span>
 
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MaxDigit <span class="hljs-number">4</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Radix <span class="hljs-number">10</span></span>
 
<span class="hljs-comment">/* 桶元素结点 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Node *PtrToNode;
<span class="hljs-keyword">struct</span> Node{
    <span class="hljs-keyword">int</span> key;
    PtrToNode next;
};
 
<span class="hljs-comment">/* 桶头结点 */</span>
<span class="hljs-keyword">struct</span> HeadNode {
    PtrToNode head, tail;
};
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> HeadNode Bucket[Radix];
  
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetDigit</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> D )</span>
</span>{ <span class="hljs-comment">/* 默认次位D=1, 主位D&lt;=MaxDigit */</span>
    <span class="hljs-keyword">int</span> d, i;
     
    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=D; i++) {
        d = X%Radix;
        X /= Radix;
    }
    <span class="hljs-keyword">return</span> d;
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MSD</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> D )</span>
</span>{ <span class="hljs-comment">/* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span>
     <span class="hljs-keyword">int</span> Di, i, j;
     Bucket B;
     PtrToNode tmp, p, List = <span class="hljs-literal">NULL</span>; 
     <span class="hljs-keyword">if</span> (D==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 递归终止条件 */</span>
      
     <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Radix; i++) <span class="hljs-comment">/* 初始化每个桶为空链表 */</span>
         B[i].head = B[i].tail = <span class="hljs-literal">NULL</span>;
     <span class="hljs-keyword">for</span> (i=L; i&lt;=R; i++) { <span class="hljs-comment">/* 将原始序列逆序存入初始链表List */</span>
         tmp = (PtrToNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));
         tmp-&gt;key = A[i];
         tmp-&gt;next = List;
         List = tmp;
     }
     <span class="hljs-comment">/* 下面是分配的过程 */</span>
     p = List;
     <span class="hljs-keyword">while</span> (p) {
         Di = GetDigit(p-&gt;key, D); <span class="hljs-comment">/* 获得当前元素的当前位数字 */</span>
         <span class="hljs-comment">/* 从List中摘除 */</span>
         tmp = p; p = p-&gt;next;
         <span class="hljs-comment">/* 插入B[Di]号桶 */</span>
         <span class="hljs-keyword">if</span> (B[Di].head == <span class="hljs-literal">NULL</span>) B[Di].tail = tmp;
         tmp-&gt;next = B[Di].head;
         B[Di].head = tmp;
     }
     <span class="hljs-comment">/* 下面是收集的过程 */</span>
     i = j = L; <span class="hljs-comment">/* i, j记录当前要处理的A[]的左右端下标 */</span>
     <span class="hljs-keyword">for</span> (Di=<span class="hljs-number">0</span>; Di&lt;Radix; Di++) { <span class="hljs-comment">/* 对于每个桶 */</span>
         <span class="hljs-keyword">if</span> (B[Di].head) { <span class="hljs-comment">/* 将非空的桶整桶倒入A[], 递归排序 */</span>
             p = B[Di].head;
             <span class="hljs-keyword">while</span> (p) {
                 tmp = p;
                 p = p-&gt;next;
                 A[j++] = tmp-&gt;key;
                 <span class="hljs-built_in">free</span>(tmp);
             }
             <span class="hljs-comment">/* 递归对该桶数据排序, 位数减1 */</span>
             MSD(A, i, j-<span class="hljs-number">1</span>, D-<span class="hljs-number">1</span>);
             i = j; <span class="hljs-comment">/* 为下一个桶对应的A[]左端 */</span>
         } 
     } 
}
 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MSDRadixSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span>
</span>{ <span class="hljs-comment">/* 统一接口 */</span>
    MSD(A, <span class="hljs-number">0</span>, N-<span class="hljs-number">1</span>, MaxDigit); 
}

</code></pre>

</body></html>